"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/uuidv7";
exports.ids = ["vendor-chunks/uuidv7"];
exports.modules = {

/***/ "(rsc)/./node_modules/uuidv7/dist/index.cjs":
/*!********************************************!*\
  !*** ./node_modules/uuidv7/dist/index.cjs ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * uuidv7: An experimental implementation of the proposed UUID Version 7\n *\n * @license Apache-2.0\n * @copyright 2021-2023 LiosK\n * @packageDocumentation\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.uuidv4obj = exports.uuidv4 = exports.uuidv7obj = exports.uuidv7 = exports.V7Generator = exports.UUID = void 0;\nconst DIGITS = \"0123456789abcdef\";\n/** Represents a UUID as a 16-byte byte array. */\nclass UUID {\n    /** @param bytes - The 16-byte byte array representation. */\n    constructor(bytes) {\n        this.bytes = bytes;\n    }\n    /**\n     * Creates an object from the internal representation, a 16-byte byte array\n     * containing the binary UUID representation in the big-endian byte order.\n     *\n     * This method does NOT shallow-copy the argument, and thus the created object\n     * holds the reference to the underlying buffer.\n     *\n     * @throws TypeError if the length of the argument is not 16.\n     */\n    static ofInner(bytes) {\n        if (bytes.length !== 16) {\n            throw new TypeError(\"not 128-bit length\");\n        }\n        else {\n            return new UUID(bytes);\n        }\n    }\n    /**\n     * Builds a byte array from UUIDv7 field values.\n     *\n     * @param unixTsMs - A 48-bit `unix_ts_ms` field value.\n     * @param randA - A 12-bit `rand_a` field value.\n     * @param randBHi - The higher 30 bits of 62-bit `rand_b` field value.\n     * @param randBLo - The lower 32 bits of 62-bit `rand_b` field value.\n     * @throws RangeError if any field value is out of the specified range.\n     */\n    static fromFieldsV7(unixTsMs, randA, randBHi, randBLo) {\n        if (!Number.isInteger(unixTsMs) ||\n            !Number.isInteger(randA) ||\n            !Number.isInteger(randBHi) ||\n            !Number.isInteger(randBLo) ||\n            unixTsMs < 0 ||\n            randA < 0 ||\n            randBHi < 0 ||\n            randBLo < 0 ||\n            unixTsMs > 281474976710655 ||\n            randA > 0xfff ||\n            randBHi > 1073741823 ||\n            randBLo > 4294967295) {\n            throw new RangeError(\"invalid field value\");\n        }\n        const bytes = new Uint8Array(16);\n        bytes[0] = unixTsMs / 2 ** 40;\n        bytes[1] = unixTsMs / 2 ** 32;\n        bytes[2] = unixTsMs / 2 ** 24;\n        bytes[3] = unixTsMs / 2 ** 16;\n        bytes[4] = unixTsMs / 2 ** 8;\n        bytes[5] = unixTsMs;\n        bytes[6] = 0x70 | (randA >>> 8);\n        bytes[7] = randA;\n        bytes[8] = 0x80 | (randBHi >>> 24);\n        bytes[9] = randBHi >>> 16;\n        bytes[10] = randBHi >>> 8;\n        bytes[11] = randBHi;\n        bytes[12] = randBLo >>> 24;\n        bytes[13] = randBLo >>> 16;\n        bytes[14] = randBLo >>> 8;\n        bytes[15] = randBLo;\n        return new UUID(bytes);\n    }\n    /**\n     * Builds a byte array from a string representation.\n     *\n     * This method accepts the following formats:\n     *\n     * - 32-digit hexadecimal format without hyphens: `0189dcd553117d408db09496a2eef37b`\n     * - 8-4-4-4-12 hyphenated format: `0189dcd5-5311-7d40-8db0-9496a2eef37b`\n     * - Hyphenated format with surrounding braces: `{0189dcd5-5311-7d40-8db0-9496a2eef37b}`\n     * - RFC 4122 URN format: `urn:uuid:0189dcd5-5311-7d40-8db0-9496a2eef37b`\n     *\n     * Leading and trailing whitespaces represents an error.\n     *\n     * @throws SyntaxError if the argument could not parse as a valid UUID string.\n     */\n    static parse(uuid) {\n        var _a, _b, _c, _d;\n        let hex = undefined;\n        switch (uuid.length) {\n            case 32:\n                hex = (_a = /^[0-9a-f]{32}$/i.exec(uuid)) === null || _a === void 0 ? void 0 : _a[0];\n                break;\n            case 36:\n                hex =\n                    (_b = /^([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/i\n                        .exec(uuid)) === null || _b === void 0 ? void 0 : _b.slice(1, 6).join(\"\");\n                break;\n            case 38:\n                hex =\n                    (_c = /^\\{([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})\\}$/i\n                        .exec(uuid)) === null || _c === void 0 ? void 0 : _c.slice(1, 6).join(\"\");\n                break;\n            case 45:\n                hex =\n                    (_d = /^urn:uuid:([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/i\n                        .exec(uuid)) === null || _d === void 0 ? void 0 : _d.slice(1, 6).join(\"\");\n                break;\n            default:\n                break;\n        }\n        if (hex) {\n            const inner = new Uint8Array(16);\n            for (let i = 0; i < 16; i += 4) {\n                const n = parseInt(hex.substring(2 * i, 2 * i + 8), 16);\n                inner[i + 0] = n >>> 24;\n                inner[i + 1] = n >>> 16;\n                inner[i + 2] = n >>> 8;\n                inner[i + 3] = n;\n            }\n            return new UUID(inner);\n        }\n        else {\n            throw new SyntaxError(\"could not parse UUID string\");\n        }\n    }\n    /**\n     * @returns The 8-4-4-4-12 canonical hexadecimal string representation\n     * (`0189dcd5-5311-7d40-8db0-9496a2eef37b`).\n     */\n    toString() {\n        let text = \"\";\n        for (let i = 0; i < this.bytes.length; i++) {\n            text += DIGITS.charAt(this.bytes[i] >>> 4);\n            text += DIGITS.charAt(this.bytes[i] & 0xf);\n            if (i === 3 || i === 5 || i === 7 || i === 9) {\n                text += \"-\";\n            }\n        }\n        return text;\n    }\n    /**\n     * @returns The 32-digit hexadecimal representation without hyphens\n     * (`0189dcd553117d408db09496a2eef37b`).\n     */\n    toHex() {\n        let text = \"\";\n        for (let i = 0; i < this.bytes.length; i++) {\n            text += DIGITS.charAt(this.bytes[i] >>> 4);\n            text += DIGITS.charAt(this.bytes[i] & 0xf);\n        }\n        return text;\n    }\n    /** @returns The 8-4-4-4-12 canonical hexadecimal string representation. */\n    toJSON() {\n        return this.toString();\n    }\n    /**\n     * Reports the variant field value of the UUID or, if appropriate, \"NIL\" or\n     * \"MAX\".\n     *\n     * For convenience, this method reports \"NIL\" or \"MAX\" if `this` represents\n     * the Nil or Max UUID, although the Nil and Max UUIDs are technically\n     * subsumed under the variants `0b0` and `0b111`, respectively.\n     */\n    getVariant() {\n        const n = this.bytes[8] >>> 4;\n        if (n < 0) {\n            throw new Error(\"unreachable\");\n        }\n        else if (n <= 0b0111) {\n            return this.bytes.every((e) => e === 0) ? \"NIL\" : \"VAR_0\";\n        }\n        else if (n <= 0b1011) {\n            return \"VAR_10\";\n        }\n        else if (n <= 0b1101) {\n            return \"VAR_110\";\n        }\n        else if (n <= 0b1111) {\n            return this.bytes.every((e) => e === 0xff) ? \"MAX\" : \"VAR_RESERVED\";\n        }\n        else {\n            throw new Error(\"unreachable\");\n        }\n    }\n    /**\n     * Returns the version field value of the UUID or `undefined` if the UUID does\n     * not have the variant field value of `0b10`.\n     */\n    getVersion() {\n        return this.getVariant() === \"VAR_10\" ? this.bytes[6] >>> 4 : undefined;\n    }\n    /** Creates an object from `this`. */\n    clone() {\n        return new UUID(this.bytes.slice(0));\n    }\n    /** Returns true if `this` is equivalent to `other`. */\n    equals(other) {\n        return this.compareTo(other) === 0;\n    }\n    /**\n     * Returns a negative integer, zero, or positive integer if `this` is less\n     * than, equal to, or greater than `other`, respectively.\n     */\n    compareTo(other) {\n        for (let i = 0; i < 16; i++) {\n            const diff = this.bytes[i] - other.bytes[i];\n            if (diff !== 0) {\n                return Math.sign(diff);\n            }\n        }\n        return 0;\n    }\n}\nexports.UUID = UUID;\n/**\n * Encapsulates the monotonic counter state.\n *\n * This class provides APIs to utilize a separate counter state from that of the\n * global generator used by {@link uuidv7} and {@link uuidv7obj}. In addition to\n * the default {@link generate} method, this class has {@link generateOrAbort}\n * that is useful to absolutely guarantee the monotonically increasing order of\n * generated UUIDs. See their respective documentation for details.\n */\nclass V7Generator {\n    /**\n     * Creates a generator object with the default random number generator, or\n     * with the specified one if passed as an argument. The specified random\n     * number generator should be cryptographically strong and securely seeded.\n     */\n    constructor(randomNumberGenerator) {\n        this.timestamp = 0;\n        this.counter = 0;\n        this.random = randomNumberGenerator !== null && randomNumberGenerator !== void 0 ? randomNumberGenerator : getDefaultRandom();\n    }\n    /**\n     * Generates a new UUIDv7 object from the current timestamp, or resets the\n     * generator upon significant timestamp rollback.\n     *\n     * This method returns a monotonically increasing UUID by reusing the previous\n     * timestamp even if the up-to-date timestamp is smaller than the immediately\n     * preceding UUID's. However, when such a clock rollback is considered\n     * significant (i.e., by more than ten seconds), this method resets the\n     * generator and returns a new UUID based on the given timestamp, breaking the\n     * increasing order of UUIDs.\n     *\n     * See {@link generateOrAbort} for the other mode of generation and\n     * {@link generateOrResetCore} for the low-level primitive.\n     */\n    generate() {\n        return this.generateOrResetCore(Date.now(), 10000);\n    }\n    /**\n     * Generates a new UUIDv7 object from the current timestamp, or returns\n     * `undefined` upon significant timestamp rollback.\n     *\n     * This method returns a monotonically increasing UUID by reusing the previous\n     * timestamp even if the up-to-date timestamp is smaller than the immediately\n     * preceding UUID's. However, when such a clock rollback is considered\n     * significant (i.e., by more than ten seconds), this method aborts and\n     * returns `undefined` immediately.\n     *\n     * See {@link generate} for the other mode of generation and\n     * {@link generateOrAbortCore} for the low-level primitive.\n     */\n    generateOrAbort() {\n        return this.generateOrAbortCore(Date.now(), 10000);\n    }\n    /**\n     * Generates a new UUIDv7 object from the `unixTsMs` passed, or resets the\n     * generator upon significant timestamp rollback.\n     *\n     * This method is equivalent to {@link generate} except that it takes a custom\n     * timestamp and clock rollback allowance.\n     *\n     * @param rollbackAllowance - The amount of `unixTsMs` rollback that is\n     * considered significant. A suggested value is `10_000` (milliseconds).\n     * @throws RangeError if `unixTsMs` is not a 48-bit positive integer.\n     */\n    generateOrResetCore(unixTsMs, rollbackAllowance) {\n        let value = this.generateOrAbortCore(unixTsMs, rollbackAllowance);\n        if (value === undefined) {\n            // reset state and resume\n            this.timestamp = 0;\n            value = this.generateOrAbortCore(unixTsMs, rollbackAllowance);\n        }\n        return value;\n    }\n    /**\n     * Generates a new UUIDv7 object from the `unixTsMs` passed, or returns\n     * `undefined` upon significant timestamp rollback.\n     *\n     * This method is equivalent to {@link generateOrAbort} except that it takes a\n     * custom timestamp and clock rollback allowance.\n     *\n     * @param rollbackAllowance - The amount of `unixTsMs` rollback that is\n     * considered significant. A suggested value is `10_000` (milliseconds).\n     * @throws RangeError if `unixTsMs` is not a 48-bit positive integer.\n     */\n    generateOrAbortCore(unixTsMs, rollbackAllowance) {\n        const MAX_COUNTER = 4398046511103;\n        if (!Number.isInteger(unixTsMs) ||\n            unixTsMs < 1 ||\n            unixTsMs > 281474976710655) {\n            throw new RangeError(\"`unixTsMs` must be a 48-bit positive integer\");\n        }\n        else if (rollbackAllowance < 0 || rollbackAllowance > 281474976710655) {\n            throw new RangeError(\"`rollbackAllowance` out of reasonable range\");\n        }\n        if (unixTsMs > this.timestamp) {\n            this.timestamp = unixTsMs;\n            this.resetCounter();\n        }\n        else if (unixTsMs + rollbackAllowance >= this.timestamp) {\n            // go on with previous timestamp if new one is not much smaller\n            this.counter++;\n            if (this.counter > MAX_COUNTER) {\n                // increment timestamp at counter overflow\n                this.timestamp++;\n                this.resetCounter();\n            }\n        }\n        else {\n            // abort if clock went backwards to unbearable extent\n            return undefined;\n        }\n        return UUID.fromFieldsV7(this.timestamp, Math.trunc(this.counter / 2 ** 30), this.counter & (2 ** 30 - 1), this.random.nextUint32());\n    }\n    /** Initializes the counter at a 42-bit random integer. */\n    resetCounter() {\n        this.counter =\n            this.random.nextUint32() * 0x400 + (this.random.nextUint32() & 0x3ff);\n    }\n    /**\n     * Generates a new UUIDv4 object utilizing the random number generator inside.\n     *\n     * @internal\n     */\n    generateV4() {\n        const bytes = new Uint8Array(Uint32Array.of(this.random.nextUint32(), this.random.nextUint32(), this.random.nextUint32(), this.random.nextUint32()).buffer);\n        bytes[6] = 0x40 | (bytes[6] >>> 4);\n        bytes[8] = 0x80 | (bytes[8] >>> 2);\n        return UUID.ofInner(bytes);\n    }\n}\nexports.V7Generator = V7Generator;\n/** Returns the default random number generator available in the environment. */\nconst getDefaultRandom = () => {\n    // detect Web Crypto API\n    if (typeof crypto !== \"undefined\" &&\n        typeof crypto.getRandomValues !== \"undefined\") {\n        return new BufferedCryptoRandom();\n    }\n    else {\n        // fall back on Math.random() unless the flag is set to true\n        if (typeof UUIDV7_DENY_WEAK_RNG !== \"undefined\" && UUIDV7_DENY_WEAK_RNG) {\n            throw new Error(\"no cryptographically strong RNG available\");\n        }\n        return {\n            nextUint32: () => Math.trunc(Math.random() * 65536) * 65536 +\n                Math.trunc(Math.random() * 65536),\n        };\n    }\n};\n/**\n * Wraps `crypto.getRandomValues()` to enable buffering; this uses a small\n * buffer by default to avoid both unbearable throughput decline in some\n * environments and the waste of time and space for unused values.\n */\nclass BufferedCryptoRandom {\n    constructor() {\n        this.buffer = new Uint32Array(8);\n        this.cursor = 0xffff;\n    }\n    nextUint32() {\n        if (this.cursor >= this.buffer.length) {\n            crypto.getRandomValues(this.buffer);\n            this.cursor = 0;\n        }\n        return this.buffer[this.cursor++];\n    }\n}\nlet defaultGenerator;\n/**\n * Generates a UUIDv7 string.\n *\n * @returns The 8-4-4-4-12 canonical hexadecimal string representation\n * (\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\").\n */\nconst uuidv7 = () => (0, exports.uuidv7obj)().toString();\nexports.uuidv7 = uuidv7;\n/** Generates a UUIDv7 object. */\nconst uuidv7obj = () => (defaultGenerator || (defaultGenerator = new V7Generator())).generate();\nexports.uuidv7obj = uuidv7obj;\n/**\n * Generates a UUIDv4 string.\n *\n * @returns The 8-4-4-4-12 canonical hexadecimal string representation\n * (\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\").\n */\nconst uuidv4 = () => (0, exports.uuidv4obj)().toString();\nexports.uuidv4 = uuidv4;\n/** Generates a UUIDv4 object. */\nconst uuidv4obj = () => (defaultGenerator || (defaultGenerator = new V7Generator())).generateV4();\nexports.uuidv4obj = uuidv4obj;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdXVpZHY3L2Rpc3QvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLEdBQUcsY0FBYyxHQUFHLGlCQUFpQixHQUFHLGNBQWMsR0FBRyxtQkFBbUIsR0FBRyxZQUFZO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QscUNBQXFDO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsR0FBRztBQUMxQztBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsRUFBRSxZQUFZLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSxZQUFZLEdBQUc7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsVUFBVSxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsWUFBWSxFQUFFLFlBQVksR0FBRyxHQUFHO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSxZQUFZLEVB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ZXMvdXVpZHY3L2Rpc3QvaW5kZXguY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiB1dWlkdjc6IEFuIGV4cGVyaW1lbnRhbCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgcHJvcG9zZWQgVVVJRCBWZXJzaW9uIDdcbiAqXG4gKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4gKiBAY29weXJpZ2h0IDIwMjEtMjAyMyBMaW9zS1xuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudXVpZHY0b2JqID0gZXhwb3J0cy51dWlkdjQgPSBleHBvcnRzLnV1aWR2N29iaiA9IGV4cG9ydHMudXVpZHY3ID0gZXhwb3J0cy5WN0dlbmVyYXRvciA9IGV4cG9ydHMuVVVJRCA9IHZvaWQgMDtcbmNvbnN0IERJR0lUUyA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuLyoqIFJlcHJlc2VudHMgYSBVVUlEIGFzIGEgMTYtYnl0ZSBieXRlIGFycmF5LiAqL1xuY2xhc3MgVVVJRCB7XG4gICAgLyoqIEBwYXJhbSBieXRlcyAtIFRoZSAxNi1ieXRlIGJ5dGUgYXJyYXkgcmVwcmVzZW50YXRpb24uICovXG4gICAgY29uc3RydWN0b3IoYnl0ZXMpIHtcbiAgICAgICAgdGhpcy5ieXRlcyA9IGJ5dGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBmcm9tIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiwgYSAxNi1ieXRlIGJ5dGUgYXJyYXlcbiAgICAgKiBjb250YWluaW5nIHRoZSBiaW5hcnkgVVVJRCByZXByZXNlbnRhdGlvbiBpbiB0aGUgYmlnLWVuZGlhbiBieXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgZG9lcyBOT1Qgc2hhbGxvdy1jb3B5IHRoZSBhcmd1bWVudCwgYW5kIHRodXMgdGhlIGNyZWF0ZWQgb2JqZWN0XG4gICAgICogaG9sZHMgdGhlIHJlZmVyZW5jZSB0byB0aGUgdW5kZXJseWluZyBidWZmZXIuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIFR5cGVFcnJvciBpZiB0aGUgbGVuZ3RoIG9mIHRoZSBhcmd1bWVudCBpcyBub3QgMTYuXG4gICAgICovXG4gICAgc3RhdGljIG9mSW5uZXIoYnl0ZXMpIHtcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gMTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJub3QgMTI4LWJpdCBsZW5ndGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVVSUQoYnl0ZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBhIGJ5dGUgYXJyYXkgZnJvbSBVVUlEdjcgZmllbGQgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVuaXhUc01zIC0gQSA0OC1iaXQgYHVuaXhfdHNfbXNgIGZpZWxkIHZhbHVlLlxuICAgICAqIEBwYXJhbSByYW5kQSAtIEEgMTItYml0IGByYW5kX2FgIGZpZWxkIHZhbHVlLlxuICAgICAqIEBwYXJhbSByYW5kQkhpIC0gVGhlIGhpZ2hlciAzMCBiaXRzIG9mIDYyLWJpdCBgcmFuZF9iYCBmaWVsZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gcmFuZEJMbyAtIFRoZSBsb3dlciAzMiBiaXRzIG9mIDYyLWJpdCBgcmFuZF9iYCBmaWVsZCB2YWx1ZS5cbiAgICAgKiBAdGhyb3dzIFJhbmdlRXJyb3IgaWYgYW55IGZpZWxkIHZhbHVlIGlzIG91dCBvZiB0aGUgc3BlY2lmaWVkIHJhbmdlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tRmllbGRzVjcodW5peFRzTXMsIHJhbmRBLCByYW5kQkhpLCByYW5kQkxvKSB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcih1bml4VHNNcykgfHxcbiAgICAgICAgICAgICFOdW1iZXIuaXNJbnRlZ2VyKHJhbmRBKSB8fFxuICAgICAgICAgICAgIU51bWJlci5pc0ludGVnZXIocmFuZEJIaSkgfHxcbiAgICAgICAgICAgICFOdW1iZXIuaXNJbnRlZ2VyKHJhbmRCTG8pIHx8XG4gICAgICAgICAgICB1bml4VHNNcyA8IDAgfHxcbiAgICAgICAgICAgIHJhbmRBIDwgMCB8fFxuICAgICAgICAgICAgcmFuZEJIaSA8IDAgfHxcbiAgICAgICAgICAgIHJhbmRCTG8gPCAwIHx8XG4gICAgICAgICAgICB1bml4VHNNcyA+IDI4MTQ3NDk3NjcxMDY1NSB8fFxuICAgICAgICAgICAgcmFuZEEgPiAweGZmZiB8fFxuICAgICAgICAgICAgcmFuZEJIaSA+IDEwNzM3NDE4MjMgfHxcbiAgICAgICAgICAgIHJhbmRCTG8gPiA0Mjk0OTY3Mjk1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImludmFsaWQgZmllbGQgdmFsdWVcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgICAgIGJ5dGVzWzBdID0gdW5peFRzTXMgLyAyICoqIDQwO1xuICAgICAgICBieXRlc1sxXSA9IHVuaXhUc01zIC8gMiAqKiAzMjtcbiAgICAgICAgYnl0ZXNbMl0gPSB1bml4VHNNcyAvIDIgKiogMjQ7XG4gICAgICAgIGJ5dGVzWzNdID0gdW5peFRzTXMgLyAyICoqIDE2O1xuICAgICAgICBieXRlc1s0XSA9IHVuaXhUc01zIC8gMiAqKiA4O1xuICAgICAgICBieXRlc1s1XSA9IHVuaXhUc01zO1xuICAgICAgICBieXRlc1s2XSA9IDB4NzAgfCAocmFuZEEgPj4+IDgpO1xuICAgICAgICBieXRlc1s3XSA9IHJhbmRBO1xuICAgICAgICBieXRlc1s4XSA9IDB4ODAgfCAocmFuZEJIaSA+Pj4gMjQpO1xuICAgICAgICBieXRlc1s5XSA9IHJhbmRCSGkgPj4+IDE2O1xuICAgICAgICBieXRlc1sxMF0gPSByYW5kQkhpID4+PiA4O1xuICAgICAgICBieXRlc1sxMV0gPSByYW5kQkhpO1xuICAgICAgICBieXRlc1sxMl0gPSByYW5kQkxvID4+PiAyNDtcbiAgICAgICAgYnl0ZXNbMTNdID0gcmFuZEJMbyA+Pj4gMTY7XG4gICAgICAgIGJ5dGVzWzE0XSA9IHJhbmRCTG8gPj4+IDg7XG4gICAgICAgIGJ5dGVzWzE1XSA9IHJhbmRCTG87XG4gICAgICAgIHJldHVybiBuZXcgVVVJRChieXRlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBhIGJ5dGUgYXJyYXkgZnJvbSBhIHN0cmluZyByZXByZXNlbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGFjY2VwdHMgdGhlIGZvbGxvd2luZyBmb3JtYXRzOlxuICAgICAqXG4gICAgICogLSAzMi1kaWdpdCBoZXhhZGVjaW1hbCBmb3JtYXQgd2l0aG91dCBoeXBoZW5zOiBgMDE4OWRjZDU1MzExN2Q0MDhkYjA5NDk2YTJlZWYzN2JgXG4gICAgICogLSA4LTQtNC00LTEyIGh5cGhlbmF0ZWQgZm9ybWF0OiBgMDE4OWRjZDUtNTMxMS03ZDQwLThkYjAtOTQ5NmEyZWVmMzdiYFxuICAgICAqIC0gSHlwaGVuYXRlZCBmb3JtYXQgd2l0aCBzdXJyb3VuZGluZyBicmFjZXM6IGB7MDE4OWRjZDUtNTMxMS03ZDQwLThkYjAtOTQ5NmEyZWVmMzdifWBcbiAgICAgKiAtIFJGQyA0MTIyIFVSTiBmb3JtYXQ6IGB1cm46dXVpZDowMTg5ZGNkNS01MzExLTdkNDAtOGRiMC05NDk2YTJlZWYzN2JgXG4gICAgICpcbiAgICAgKiBMZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlcyByZXByZXNlbnRzIGFuIGVycm9yLlxuICAgICAqXG4gICAgICogQHRocm93cyBTeW50YXhFcnJvciBpZiB0aGUgYXJndW1lbnQgY291bGQgbm90IHBhcnNlIGFzIGEgdmFsaWQgVVVJRCBzdHJpbmcuXG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlKHV1aWQpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgaGV4ID0gdW5kZWZpbmVkO1xuICAgICAgICBzd2l0Y2ggKHV1aWQubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgICAgIGhleCA9IChfYSA9IC9eWzAtOWEtZl17MzJ9JC9pLmV4ZWModXVpZCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzY6XG4gICAgICAgICAgICAgICAgaGV4ID1cbiAgICAgICAgICAgICAgICAgICAgKF9iID0gL14oWzAtOWEtZl17OH0pLShbMC05YS1mXXs0fSktKFswLTlhLWZdezR9KS0oWzAtOWEtZl17NH0pLShbMC05YS1mXXsxMn0pJC9pXG4gICAgICAgICAgICAgICAgICAgICAgICAuZXhlYyh1dWlkKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNsaWNlKDEsIDYpLmpvaW4oXCJcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgICAgICAgIGhleCA9XG4gICAgICAgICAgICAgICAgICAgIChfYyA9IC9eXFx7KFswLTlhLWZdezh9KS0oWzAtOWEtZl17NH0pLShbMC05YS1mXXs0fSktKFswLTlhLWZdezR9KS0oWzAtOWEtZl17MTJ9KVxcfSQvaVxuICAgICAgICAgICAgICAgICAgICAgICAgLmV4ZWModXVpZCkpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5zbGljZSgxLCA2KS5qb2luKFwiXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0NTpcbiAgICAgICAgICAgICAgICBoZXggPVxuICAgICAgICAgICAgICAgICAgICAoX2QgPSAvXnVybjp1dWlkOihbMC05YS1mXXs4fSktKFswLTlhLWZdezR9KS0oWzAtOWEtZl17NH0pLShbMC05YS1mXXs0fSktKFswLTlhLWZdezEyfSkkL2lcbiAgICAgICAgICAgICAgICAgICAgICAgIC5leGVjKHV1aWQpKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Quc2xpY2UoMSwgNikuam9pbihcIlwiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhleCkge1xuICAgICAgICAgICAgY29uc3QgaW5uZXIgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpICs9IDQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuID0gcGFyc2VJbnQoaGV4LnN1YnN0cmluZygyICogaSwgMiAqIGkgKyA4KSwgMTYpO1xuICAgICAgICAgICAgICAgIGlubmVyW2kgKyAwXSA9IG4gPj4+IDI0O1xuICAgICAgICAgICAgICAgIGlubmVyW2kgKyAxXSA9IG4gPj4+IDE2O1xuICAgICAgICAgICAgICAgIGlubmVyW2kgKyAyXSA9IG4gPj4+IDg7XG4gICAgICAgICAgICAgICAgaW5uZXJbaSArIDNdID0gbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgVVVJRChpbm5lcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJjb3VsZCBub3QgcGFyc2UgVVVJRCBzdHJpbmdcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgVGhlIDgtNC00LTQtMTIgY2Fub25pY2FsIGhleGFkZWNpbWFsIHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgICAqIChgMDE4OWRjZDUtNTMxMS03ZDQwLThkYjAtOTQ5NmEyZWVmMzdiYCkuXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0ZXh0ICs9IERJR0lUUy5jaGFyQXQodGhpcy5ieXRlc1tpXSA+Pj4gNCk7XG4gICAgICAgICAgICB0ZXh0ICs9IERJR0lUUy5jaGFyQXQodGhpcy5ieXRlc1tpXSAmIDB4Zik7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMyB8fCBpID09PSA1IHx8IGkgPT09IDcgfHwgaSA9PT0gOSkge1xuICAgICAgICAgICAgICAgIHRleHQgKz0gXCItXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFRoZSAzMi1kaWdpdCBoZXhhZGVjaW1hbCByZXByZXNlbnRhdGlvbiB3aXRob3V0IGh5cGhlbnNcbiAgICAgKiAoYDAxODlkY2Q1NTMxMTdkNDA4ZGIwOTQ5NmEyZWVmMzdiYCkuXG4gICAgICovXG4gICAgdG9IZXgoKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0ZXh0ICs9IERJR0lUUy5jaGFyQXQodGhpcy5ieXRlc1tpXSA+Pj4gNCk7XG4gICAgICAgICAgICB0ZXh0ICs9IERJR0lUUy5jaGFyQXQodGhpcy5ieXRlc1tpXSAmIDB4Zik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIC8qKiBAcmV0dXJucyBUaGUgOC00LTQtNC0xMiBjYW5vbmljYWwgaGV4YWRlY2ltYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uLiAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVwb3J0cyB0aGUgdmFyaWFudCBmaWVsZCB2YWx1ZSBvZiB0aGUgVVVJRCBvciwgaWYgYXBwcm9wcmlhdGUsIFwiTklMXCIgb3JcbiAgICAgKiBcIk1BWFwiLlxuICAgICAqXG4gICAgICogRm9yIGNvbnZlbmllbmNlLCB0aGlzIG1ldGhvZCByZXBvcnRzIFwiTklMXCIgb3IgXCJNQVhcIiBpZiBgdGhpc2AgcmVwcmVzZW50c1xuICAgICAqIHRoZSBOaWwgb3IgTWF4IFVVSUQsIGFsdGhvdWdoIHRoZSBOaWwgYW5kIE1heCBVVUlEcyBhcmUgdGVjaG5pY2FsbHlcbiAgICAgKiBzdWJzdW1lZCB1bmRlciB0aGUgdmFyaWFudHMgYDBiMGAgYW5kIGAwYjExMWAsIHJlc3BlY3RpdmVseS5cbiAgICAgKi9cbiAgICBnZXRWYXJpYW50KCkge1xuICAgICAgICBjb25zdCBuID0gdGhpcy5ieXRlc1s4XSA+Pj4gNDtcbiAgICAgICAgaWYgKG4gPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnJlYWNoYWJsZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuIDw9IDBiMDExMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXMuZXZlcnkoKGUpID0+IGUgPT09IDApID8gXCJOSUxcIiA6IFwiVkFSXzBcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuIDw9IDBiMTAxMSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiVkFSXzEwXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobiA8PSAwYjExMDEpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlZBUl8xMTBcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuIDw9IDBiMTExMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXMuZXZlcnkoKGUpID0+IGUgPT09IDB4ZmYpID8gXCJNQVhcIiA6IFwiVkFSX1JFU0VSVkVEXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnJlYWNoYWJsZVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2ZXJzaW9uIGZpZWxkIHZhbHVlIG9mIHRoZSBVVUlEIG9yIGB1bmRlZmluZWRgIGlmIHRoZSBVVUlEIGRvZXNcbiAgICAgKiBub3QgaGF2ZSB0aGUgdmFyaWFudCBmaWVsZCB2YWx1ZSBvZiBgMGIxMGAuXG4gICAgICovXG4gICAgZ2V0VmVyc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFyaWFudCgpID09PSBcIlZBUl8xMFwiID8gdGhpcy5ieXRlc1s2XSA+Pj4gNCA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqIENyZWF0ZXMgYW4gb2JqZWN0IGZyb20gYHRoaXNgLiAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IFVVSUQodGhpcy5ieXRlcy5zbGljZSgwKSk7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgYHRoaXNgIGlzIGVxdWl2YWxlbnQgdG8gYG90aGVyYC4gKi9cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZVRvKG90aGVyKSA9PT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5lZ2F0aXZlIGludGVnZXIsIHplcm8sIG9yIHBvc2l0aXZlIGludGVnZXIgaWYgYHRoaXNgIGlzIGxlc3NcbiAgICAgKiB0aGFuLCBlcXVhbCB0bywgb3IgZ3JlYXRlciB0aGFuIGBvdGhlcmAsIHJlc3BlY3RpdmVseS5cbiAgICAgKi9cbiAgICBjb21wYXJlVG8ob3RoZXIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBkaWZmID0gdGhpcy5ieXRlc1tpXSAtIG90aGVyLmJ5dGVzW2ldO1xuICAgICAgICAgICAgaWYgKGRpZmYgIT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5zaWduKGRpZmYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn1cbmV4cG9ydHMuVVVJRCA9IFVVSUQ7XG4vKipcbiAqIEVuY2Fwc3VsYXRlcyB0aGUgbW9ub3RvbmljIGNvdW50ZXIgc3RhdGUuXG4gKlxuICogVGhpcyBjbGFzcyBwcm92aWRlcyBBUElzIHRvIHV0aWxpemUgYSBzZXBhcmF0ZSBjb3VudGVyIHN0YXRlIGZyb20gdGhhdCBvZiB0aGVcbiAqIGdsb2JhbCBnZW5lcmF0b3IgdXNlZCBieSB7QGxpbmsgdXVpZHY3fSBhbmQge0BsaW5rIHV1aWR2N29ian0uIEluIGFkZGl0aW9uIHRvXG4gKiB0aGUgZGVmYXVsdCB7QGxpbmsgZ2VuZXJhdGV9IG1ldGhvZCwgdGhpcyBjbGFzcyBoYXMge0BsaW5rIGdlbmVyYXRlT3JBYm9ydH1cbiAqIHRoYXQgaXMgdXNlZnVsIHRvIGFic29sdXRlbHkgZ3VhcmFudGVlIHRoZSBtb25vdG9uaWNhbGx5IGluY3JlYXNpbmcgb3JkZXIgb2ZcbiAqIGdlbmVyYXRlZCBVVUlEcy4gU2VlIHRoZWlyIHJlc3BlY3RpdmUgZG9jdW1lbnRhdGlvbiBmb3IgZGV0YWlscy5cbiAqL1xuY2xhc3MgVjdHZW5lcmF0b3Ige1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBnZW5lcmF0b3Igb2JqZWN0IHdpdGggdGhlIGRlZmF1bHQgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IsIG9yXG4gICAgICogd2l0aCB0aGUgc3BlY2lmaWVkIG9uZSBpZiBwYXNzZWQgYXMgYW4gYXJndW1lbnQuIFRoZSBzcGVjaWZpZWQgcmFuZG9tXG4gICAgICogbnVtYmVyIGdlbmVyYXRvciBzaG91bGQgYmUgY3J5cHRvZ3JhcGhpY2FsbHkgc3Ryb25nIGFuZCBzZWN1cmVseSBzZWVkZWQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmFuZG9tTnVtYmVyR2VuZXJhdG9yKSB7XG4gICAgICAgIHRoaXMudGltZXN0YW1wID0gMDtcbiAgICAgICAgdGhpcy5jb3VudGVyID0gMDtcbiAgICAgICAgdGhpcy5yYW5kb20gPSByYW5kb21OdW1iZXJHZW5lcmF0b3IgIT09IG51bGwgJiYgcmFuZG9tTnVtYmVyR2VuZXJhdG9yICE9PSB2b2lkIDAgPyByYW5kb21OdW1iZXJHZW5lcmF0b3IgOiBnZXREZWZhdWx0UmFuZG9tKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIG5ldyBVVUlEdjcgb2JqZWN0IGZyb20gdGhlIGN1cnJlbnQgdGltZXN0YW1wLCBvciByZXNldHMgdGhlXG4gICAgICogZ2VuZXJhdG9yIHVwb24gc2lnbmlmaWNhbnQgdGltZXN0YW1wIHJvbGxiYWNrLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG1vbm90b25pY2FsbHkgaW5jcmVhc2luZyBVVUlEIGJ5IHJldXNpbmcgdGhlIHByZXZpb3VzXG4gICAgICogdGltZXN0YW1wIGV2ZW4gaWYgdGhlIHVwLXRvLWRhdGUgdGltZXN0YW1wIGlzIHNtYWxsZXIgdGhhbiB0aGUgaW1tZWRpYXRlbHlcbiAgICAgKiBwcmVjZWRpbmcgVVVJRCdzLiBIb3dldmVyLCB3aGVuIHN1Y2ggYSBjbG9jayByb2xsYmFjayBpcyBjb25zaWRlcmVkXG4gICAgICogc2lnbmlmaWNhbnQgKGkuZS4sIGJ5IG1vcmUgdGhhbiB0ZW4gc2Vjb25kcyksIHRoaXMgbWV0aG9kIHJlc2V0cyB0aGVcbiAgICAgKiBnZW5lcmF0b3IgYW5kIHJldHVybnMgYSBuZXcgVVVJRCBiYXNlZCBvbiB0aGUgZ2l2ZW4gdGltZXN0YW1wLCBicmVha2luZyB0aGVcbiAgICAgKiBpbmNyZWFzaW5nIG9yZGVyIG9mIFVVSURzLlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBnZW5lcmF0ZU9yQWJvcnR9IGZvciB0aGUgb3RoZXIgbW9kZSBvZiBnZW5lcmF0aW9uIGFuZFxuICAgICAqIHtAbGluayBnZW5lcmF0ZU9yUmVzZXRDb3JlfSBmb3IgdGhlIGxvdy1sZXZlbCBwcmltaXRpdmUuXG4gICAgICovXG4gICAgZ2VuZXJhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlT3JSZXNldENvcmUoRGF0ZS5ub3coKSwgMTAwMDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBuZXcgVVVJRHY3IG9iamVjdCBmcm9tIHRoZSBjdXJyZW50IHRpbWVzdGFtcCwgb3IgcmV0dXJuc1xuICAgICAqIGB1bmRlZmluZWRgIHVwb24gc2lnbmlmaWNhbnQgdGltZXN0YW1wIHJvbGxiYWNrLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG1vbm90b25pY2FsbHkgaW5jcmVhc2luZyBVVUlEIGJ5IHJldXNpbmcgdGhlIHByZXZpb3VzXG4gICAgICogdGltZXN0YW1wIGV2ZW4gaWYgdGhlIHVwLXRvLWRhdGUgdGltZXN0YW1wIGlzIHNtYWxsZXIgdGhhbiB0aGUgaW1tZWRpYXRlbHlcbiAgICAgKiBwcmVjZWRpbmcgVVVJRCdzLiBIb3dldmVyLCB3aGVuIHN1Y2ggYSBjbG9jayByb2xsYmFjayBpcyBjb25zaWRlcmVkXG4gICAgICogc2lnbmlmaWNhbnQgKGkuZS4sIGJ5IG1vcmUgdGhhbiB0ZW4gc2Vjb25kcyksIHRoaXMgbWV0aG9kIGFib3J0cyBhbmRcbiAgICAgKiByZXR1cm5zIGB1bmRlZmluZWRgIGltbWVkaWF0ZWx5LlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBnZW5lcmF0ZX0gZm9yIHRoZSBvdGhlciBtb2RlIG9mIGdlbmVyYXRpb24gYW5kXG4gICAgICoge0BsaW5rIGdlbmVyYXRlT3JBYm9ydENvcmV9IGZvciB0aGUgbG93LWxldmVsIHByaW1pdGl2ZS5cbiAgICAgKi9cbiAgICBnZW5lcmF0ZU9yQWJvcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlT3JBYm9ydENvcmUoRGF0ZS5ub3coKSwgMTAwMDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBuZXcgVVVJRHY3IG9iamVjdCBmcm9tIHRoZSBgdW5peFRzTXNgIHBhc3NlZCwgb3IgcmVzZXRzIHRoZVxuICAgICAqIGdlbmVyYXRvciB1cG9uIHNpZ25pZmljYW50IHRpbWVzdGFtcCByb2xsYmFjay5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGVxdWl2YWxlbnQgdG8ge0BsaW5rIGdlbmVyYXRlfSBleGNlcHQgdGhhdCBpdCB0YWtlcyBhIGN1c3RvbVxuICAgICAqIHRpbWVzdGFtcCBhbmQgY2xvY2sgcm9sbGJhY2sgYWxsb3dhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJvbGxiYWNrQWxsb3dhbmNlIC0gVGhlIGFtb3VudCBvZiBgdW5peFRzTXNgIHJvbGxiYWNrIHRoYXQgaXNcbiAgICAgKiBjb25zaWRlcmVkIHNpZ25pZmljYW50LiBBIHN1Z2dlc3RlZCB2YWx1ZSBpcyBgMTBfMDAwYCAobWlsbGlzZWNvbmRzKS5cbiAgICAgKiBAdGhyb3dzIFJhbmdlRXJyb3IgaWYgYHVuaXhUc01zYCBpcyBub3QgYSA0OC1iaXQgcG9zaXRpdmUgaW50ZWdlci5cbiAgICAgKi9cbiAgICBnZW5lcmF0ZU9yUmVzZXRDb3JlKHVuaXhUc01zLCByb2xsYmFja0FsbG93YW5jZSkge1xuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmdlbmVyYXRlT3JBYm9ydENvcmUodW5peFRzTXMsIHJvbGxiYWNrQWxsb3dhbmNlKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHJlc2V0IHN0YXRlIGFuZCByZXN1bWVcbiAgICAgICAgICAgIHRoaXMudGltZXN0YW1wID0gMDtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5nZW5lcmF0ZU9yQWJvcnRDb3JlKHVuaXhUc01zLCByb2xsYmFja0FsbG93YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBuZXcgVVVJRHY3IG9iamVjdCBmcm9tIHRoZSBgdW5peFRzTXNgIHBhc3NlZCwgb3IgcmV0dXJuc1xuICAgICAqIGB1bmRlZmluZWRgIHVwb24gc2lnbmlmaWNhbnQgdGltZXN0YW1wIHJvbGxiYWNrLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgZXF1aXZhbGVudCB0byB7QGxpbmsgZ2VuZXJhdGVPckFib3J0fSBleGNlcHQgdGhhdCBpdCB0YWtlcyBhXG4gICAgICogY3VzdG9tIHRpbWVzdGFtcCBhbmQgY2xvY2sgcm9sbGJhY2sgYWxsb3dhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJvbGxiYWNrQWxsb3dhbmNlIC0gVGhlIGFtb3VudCBvZiBgdW5peFRzTXNgIHJvbGxiYWNrIHRoYXQgaXNcbiAgICAgKiBjb25zaWRlcmVkIHNpZ25pZmljYW50LiBBIHN1Z2dlc3RlZCB2YWx1ZSBpcyBgMTBfMDAwYCAobWlsbGlzZWNvbmRzKS5cbiAgICAgKiBAdGhyb3dzIFJhbmdlRXJyb3IgaWYgYHVuaXhUc01zYCBpcyBub3QgYSA0OC1iaXQgcG9zaXRpdmUgaW50ZWdlci5cbiAgICAgKi9cbiAgICBnZW5lcmF0ZU9yQWJvcnRDb3JlKHVuaXhUc01zLCByb2xsYmFja0FsbG93YW5jZSkge1xuICAgICAgICBjb25zdCBNQVhfQ09VTlRFUiA9IDQzOTgwNDY1MTExMDM7XG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcih1bml4VHNNcykgfHxcbiAgICAgICAgICAgIHVuaXhUc01zIDwgMSB8fFxuICAgICAgICAgICAgdW5peFRzTXMgPiAyODE0NzQ5NzY3MTA2NTUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiYHVuaXhUc01zYCBtdXN0IGJlIGEgNDgtYml0IHBvc2l0aXZlIGludGVnZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocm9sbGJhY2tBbGxvd2FuY2UgPCAwIHx8IHJvbGxiYWNrQWxsb3dhbmNlID4gMjgxNDc0OTc2NzEwNjU1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImByb2xsYmFja0FsbG93YW5jZWAgb3V0IG9mIHJlYXNvbmFibGUgcmFuZ2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaXhUc01zID4gdGhpcy50aW1lc3RhbXApIHtcbiAgICAgICAgICAgIHRoaXMudGltZXN0YW1wID0gdW5peFRzTXM7XG4gICAgICAgICAgICB0aGlzLnJlc2V0Q291bnRlcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHVuaXhUc01zICsgcm9sbGJhY2tBbGxvd2FuY2UgPj0gdGhpcy50aW1lc3RhbXApIHtcbiAgICAgICAgICAgIC8vIGdvIG9uIHdpdGggcHJldmlvdXMgdGltZXN0YW1wIGlmIG5ldyBvbmUgaXMgbm90IG11Y2ggc21hbGxlclxuICAgICAgICAgICAgdGhpcy5jb3VudGVyKys7XG4gICAgICAgICAgICBpZiAodGhpcy5jb3VudGVyID4gTUFYX0NPVU5URVIpIHtcbiAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgdGltZXN0YW1wIGF0IGNvdW50ZXIgb3ZlcmZsb3dcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVzdGFtcCsrO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXRDb3VudGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBhYm9ydCBpZiBjbG9jayB3ZW50IGJhY2t3YXJkcyB0byB1bmJlYXJhYmxlIGV4dGVudFxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVVVJRC5mcm9tRmllbGRzVjcodGhpcy50aW1lc3RhbXAsIE1hdGgudHJ1bmModGhpcy5jb3VudGVyIC8gMiAqKiAzMCksIHRoaXMuY291bnRlciAmICgyICoqIDMwIC0gMSksIHRoaXMucmFuZG9tLm5leHRVaW50MzIoKSk7XG4gICAgfVxuICAgIC8qKiBJbml0aWFsaXplcyB0aGUgY291bnRlciBhdCBhIDQyLWJpdCByYW5kb20gaW50ZWdlci4gKi9cbiAgICByZXNldENvdW50ZXIoKSB7XG4gICAgICAgIHRoaXMuY291bnRlciA9XG4gICAgICAgICAgICB0aGlzLnJhbmRvbS5uZXh0VWludDMyKCkgKiAweDQwMCArICh0aGlzLnJhbmRvbS5uZXh0VWludDMyKCkgJiAweDNmZik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIG5ldyBVVUlEdjQgb2JqZWN0IHV0aWxpemluZyB0aGUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IgaW5zaWRlLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZ2VuZXJhdGVWNCgpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShVaW50MzJBcnJheS5vZih0aGlzLnJhbmRvbS5uZXh0VWludDMyKCksIHRoaXMucmFuZG9tLm5leHRVaW50MzIoKSwgdGhpcy5yYW5kb20ubmV4dFVpbnQzMigpLCB0aGlzLnJhbmRvbS5uZXh0VWludDMyKCkpLmJ1ZmZlcik7XG4gICAgICAgIGJ5dGVzWzZdID0gMHg0MCB8IChieXRlc1s2XSA+Pj4gNCk7XG4gICAgICAgIGJ5dGVzWzhdID0gMHg4MCB8IChieXRlc1s4XSA+Pj4gMik7XG4gICAgICAgIHJldHVybiBVVUlELm9mSW5uZXIoYnl0ZXMpO1xuICAgIH1cbn1cbmV4cG9ydHMuVjdHZW5lcmF0b3IgPSBWN0dlbmVyYXRvcjtcbi8qKiBSZXR1cm5zIHRoZSBkZWZhdWx0IHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIGF2YWlsYWJsZSBpbiB0aGUgZW52aXJvbm1lbnQuICovXG5jb25zdCBnZXREZWZhdWx0UmFuZG9tID0gKCkgPT4ge1xuICAgIC8vIGRldGVjdCBXZWIgQ3J5cHRvIEFQSVxuICAgIGlmICh0eXBlb2YgY3J5cHRvICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgIHR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyZWRDcnlwdG9SYW5kb20oKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGZhbGwgYmFjayBvbiBNYXRoLnJhbmRvbSgpIHVubGVzcyB0aGUgZmxhZyBpcyBzZXQgdG8gdHJ1ZVxuICAgICAgICBpZiAodHlwZW9mIFVVSURWN19ERU5ZX1dFQUtfUk5HICE9PSBcInVuZGVmaW5lZFwiICYmIFVVSURWN19ERU5ZX1dFQUtfUk5HKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBjcnlwdG9ncmFwaGljYWxseSBzdHJvbmcgUk5HIGF2YWlsYWJsZVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmV4dFVpbnQzMjogKCkgPT4gTWF0aC50cnVuYyhNYXRoLnJhbmRvbSgpICogNjU1MzYpICogNjU1MzYgK1xuICAgICAgICAgICAgICAgIE1hdGgudHJ1bmMoTWF0aC5yYW5kb20oKSAqIDY1NTM2KSxcbiAgICAgICAgfTtcbiAgICB9XG59O1xuLyoqXG4gKiBXcmFwcyBgY3J5cHRvLmdldFJhbmRvbVZhbHVlcygpYCB0byBlbmFibGUgYnVmZmVyaW5nOyB0aGlzIHVzZXMgYSBzbWFsbFxuICogYnVmZmVyIGJ5IGRlZmF1bHQgdG8gYXZvaWQgYm90aCB1bmJlYXJhYmxlIHRocm91Z2hwdXQgZGVjbGluZSBpbiBzb21lXG4gKiBlbnZpcm9ubWVudHMgYW5kIHRoZSB3YXN0ZSBvZiB0aW1lIGFuZCBzcGFjZSBmb3IgdW51c2VkIHZhbHVlcy5cbiAqL1xuY2xhc3MgQnVmZmVyZWRDcnlwdG9SYW5kb20ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50MzJBcnJheSg4KTtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSAweGZmZmY7XG4gICAgfVxuICAgIG5leHRVaW50MzIoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnNvciA+PSB0aGlzLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXModGhpcy5idWZmZXIpO1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmN1cnNvcisrXTtcbiAgICB9XG59XG5sZXQgZGVmYXVsdEdlbmVyYXRvcjtcbi8qKlxuICogR2VuZXJhdGVzIGEgVVVJRHY3IHN0cmluZy5cbiAqXG4gKiBAcmV0dXJucyBUaGUgOC00LTQtNC0xMiBjYW5vbmljYWwgaGV4YWRlY2ltYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gKiAoXCJ4eHh4eHh4eC14eHh4LXh4eHgteHh4eC14eHh4eHh4eHh4eHhcIikuXG4gKi9cbmNvbnN0IHV1aWR2NyA9ICgpID0+ICgwLCBleHBvcnRzLnV1aWR2N29iaikoKS50b1N0cmluZygpO1xuZXhwb3J0cy51dWlkdjcgPSB1dWlkdjc7XG4vKiogR2VuZXJhdGVzIGEgVVVJRHY3IG9iamVjdC4gKi9cbmNvbnN0IHV1aWR2N29iaiA9ICgpID0+IChkZWZhdWx0R2VuZXJhdG9yIHx8IChkZWZhdWx0R2VuZXJhdG9yID0gbmV3IFY3R2VuZXJhdG9yKCkpKS5nZW5lcmF0ZSgpO1xuZXhwb3J0cy51dWlkdjdvYmogPSB1dWlkdjdvYmo7XG4vKipcbiAqIEdlbmVyYXRlcyBhIFVVSUR2NCBzdHJpbmcuXG4gKlxuICogQHJldHVybnMgVGhlIDgtNC00LTQtMTIgY2Fub25pY2FsIGhleGFkZWNpbWFsIHN0cmluZyByZXByZXNlbnRhdGlvblxuICogKFwieHh4eHh4eHgteHh4eC14eHh4LXh4eHgteHh4eHh4eHh4eHh4XCIpLlxuICovXG5jb25zdCB1dWlkdjQgPSAoKSA9PiAoMCwgZXhwb3J0cy51dWlkdjRvYmopKCkudG9TdHJpbmcoKTtcbmV4cG9ydHMudXVpZHY0ID0gdXVpZHY0O1xuLyoqIEdlbmVyYXRlcyBhIFVVSUR2NCBvYmplY3QuICovXG5jb25zdCB1dWlkdjRvYmogPSAoKSA9PiAoZGVmYXVsdEdlbmVyYXRvciB8fCAoZGVmYXVsdEdlbmVyYXRvciA9IG5ldyBWN0dlbmVyYXRvcigpKSkuZ2VuZXJhdGVWNCgpO1xuZXhwb3J0cy51dWlkdjRvYmogPSB1dWlkdjRvYmo7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/uuidv7/dist/index.cjs\n");

/***/ })

};
;